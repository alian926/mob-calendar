{"ast":null,"code":"import _objectSpread from\"/Users/alian/Desktop/git-source/react-mob-calendar/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _slicedToArray from\"/Users/alian/Desktop/git-source/react-mob-calendar/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{useState,useRef,useCallback}from'react';import isPlainObject from'lodash/isPlainObject';export function useSetState(initialState){if(!isPlainObject(initialState)){throw new Error('state is not Plain Object');}var _useState=useState(initialState),_useState2=_slicedToArray(_useState,2),state=_useState2[0],setState=_useState2[1];var setUseState=useCallback(function(patch){return setState(function(prevState){return _objectSpread(_objectSpread({},prevState),patch instanceof Function?patch(prevState):patch);});},[setState]);return[state,setUseState];}var defaultShouldUpdate=function defaultShouldUpdate(a,b){return a!==b;};export function usePrevious(state){var shouldUpdate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:defaultShouldUpdate;var prevRef=useRef();var curRef=useRef();if(shouldUpdate(curRef.current,state)){prevRef.current=curRef.current;curRef.current=state;}return prevRef.current;}","map":{"version":3,"sources":["/Users/alian/Desktop/git-source/react-mob-calendar/src/utils/hooks.ts"],"names":["useState","useRef","useCallback","isPlainObject","useSetState","initialState","Error","state","setState","setUseState","patch","prevState","Function","defaultShouldUpdate","a","b","usePrevious","shouldUpdate","prevRef","curRef","current"],"mappings":"+QAAA,OAAgBA,QAAhB,CAA0BC,MAA1B,CAAkCC,WAAlC,KAAqD,OAArD,CACA,MAAOC,CAAAA,aAAP,KAA0B,sBAA1B,CAQA,MAAO,SAASC,CAAAA,WAAT,CACHC,YADG,CAE8B,CACjC,GAAI,CAACF,aAAa,CAACE,YAAD,CAAlB,CAAkC,CAC9B,KAAM,IAAIC,CAAAA,KAAJ,CAAU,2BAAV,CAAN,CACH,CACD,cAA0BN,QAAQ,CAACK,YAAD,CAAlC,wCAAOE,KAAP,eAAcC,QAAd,eACA,GAAMC,CAAAA,WAA+B,CAAGP,WAAW,CAC/C,SAAAQ,KAAK,QACDF,CAAAA,QAAQ,CAAC,SAAAG,SAAS,wCACXA,SADW,EAEVD,KAAK,WAAYE,CAAAA,QAAjB,CAA4BF,KAAK,CAACC,SAAD,CAAjC,CAA+CD,KAFrC,GAAV,CADP,EAD0C,CAM/C,CAACF,QAAD,CAN+C,CAAnD,CAQA,MAAO,CAACD,KAAD,CAAQE,WAAR,CAAP,CACH,CAKD,GAAMI,CAAAA,mBAAmB,CAAG,QAAtBA,CAAAA,mBAAsB,CAAIC,CAAJ,CAAWC,CAAX,QAAqBD,CAAAA,CAAC,GAAKC,CAA3B,EAA5B,CAEA,MAAO,SAASC,CAAAA,WAAT,CACLT,KADK,CAGU,IADfU,CAAAA,YACe,2DADqBJ,mBACrB,CACf,GAAMK,CAAAA,OAAO,CAAGjB,MAAM,EAAtB,CACA,GAAMkB,CAAAA,MAAM,CAAGlB,MAAM,EAArB,CAEA,GAAIgB,YAAY,CAACE,MAAM,CAACC,OAAR,CAAiBb,KAAjB,CAAhB,CAAyC,CACvCW,OAAO,CAACE,OAAR,CAAkBD,MAAM,CAACC,OAAzB,CACAD,MAAM,CAACC,OAAP,CAAiBb,KAAjB,CACD,CAED,MAAOW,CAAAA,OAAO,CAACE,OAAf,CACD","sourcesContent":["import React, { useState, useRef, useCallback } from 'react';\nimport isPlainObject from 'lodash/isPlainObject';\n\ntype Patch<State> = (\n    patch: Partial<State> | ((prevPatch: State) => Partial<State>)\n) => void;\n\ntype ExcludeT<State> = Exclude<Extract<State, object>, Function>;\n\nexport function useSetState<T>(\n    initialState: ExcludeT<T>\n): [ExcludeT<T>, Patch<ExcludeT<T>>] {\n    if (!isPlainObject(initialState)) {\n        throw new Error('state is not Plain Object');\n    }\n    const [state, setState] = useState(initialState);\n    const setUseState: Patch<ExcludeT<T>> = useCallback(\n        patch =>\n            setState(prevState => ({\n                ...prevState,\n                ...(patch instanceof Function ? patch(prevState) : patch),\n            })),\n        [setState]\n    );\n    return [state, setUseState];\n}\n\n\nexport type ShouldUpdateFunc<T> = (prev: T | undefined, next: T) => boolean;\n\nconst defaultShouldUpdate = <T>(a?: T, b?: T) => a !== b;\n\nexport function usePrevious<T>(\n  state: T,\n  shouldUpdate: ShouldUpdateFunc<T> = defaultShouldUpdate,\n): T | undefined {\n  const prevRef = useRef<T>();\n  const curRef = useRef<T>();\n\n  if (shouldUpdate(curRef.current, state)) {\n    prevRef.current = curRef.current;\n    curRef.current = state;\n  }\n\n  return prevRef.current;\n}\n"]},"metadata":{},"sourceType":"module"}